// Copyright 2016 The Grin Developers
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! Implementation of Cuckoo Cycle designed by John Tromp. Ported to Rust from
//! the C and Java code at https://github.com/tromp/cuckoo. Note that only the
//! simple miner is included, mostly for testing purposes. John Tromp's Tomato
//! miner will be much faster in almost every environment.

//! Copied from Grin, for testing support
extern crate crypto;
extern crate miner;

use std::collections::HashSet;
use std::cmp;

use crypto::digest::Digest;
use crypto::sha2::Sha256;

use miner::CuckooMinerSolution;

const MAXPATHLEN: usize = 8192;
const PROOFSIZE: usize = 42;


/// A cuckoo-cycle related error
#[derive(Debug)]
pub enum Error {
	/// Unable to find a short enough path
	Path,
	/// Unable to find a solution
	NoSolution,
}

/// An edge in the Cuckoo graph, simply references two u64 nodes.
#[derive(Debug, Copy, Clone, PartialEq, PartialOrd, Eq, Ord, Hash)]
struct Edge {
	u: u64,
	v: u64,
}

/// Cuckoo cycle context
pub struct Cuckoo {
	mask: u64,
	size: u64,
	v: [u64; 4],
}

impl Cuckoo {
	/// Initializes a new Cuckoo Cycle setup, using the provided byte array to
	/// generate a seed. In practice for PoW applications the byte array is a
	/// serialized block header.
	pub fn new(header: &[u8], sizeshift: u32) -> Cuckoo {
		let size = 1 << sizeshift;
		let mut hasher = Sha256::new();
		let mut hashed = [0; 32];
		hasher.input(header);
		hasher.result(&mut hashed);

		let k0 = u8_to_u64(hashed, 0);
		let k1 = u8_to_u64(hashed, 8);
		let mut v = [0; 4];
		v[0] = k0 ^ 0x736f6d6570736575;
		v[1] = k1 ^ 0x646f72616e646f6d;
		v[2] = k0 ^ 0x6c7967656e657261;
		v[3] = k1 ^ 0x7465646279746573;
		Cuckoo {
			v: v,
			size: size,
			mask: (1 << sizeshift) / 2 - 1,
		}
	}

	/// Generates a node in the cuckoo graph generated from our seed. A node is
	/// simply materialized as a u64 from a nonce and an offset (generally 0 or
	/// 1).
	fn new_node(&self, nonce: u64, uorv: u64) -> u64 {
		return ((siphash24(self.v, 2 * nonce + uorv) & self.mask) << 1) | uorv;
	}

	/// Creates a new edge in the cuckoo graph generated by our seed from a
	/// nonce. Generates two node coordinates from the nonce and links them
	/// together.
	fn new_edge(&self, nonce: u64) -> Edge {
		Edge {
			u: self.new_node(nonce, 0),
			v: self.new_node(nonce, 1),
		}
	}

	/// Assuming increasing nonces all smaller than easiness, verifies the
	/// nonces form a cycle in a Cuckoo graph. Each nonce generates an edge, we
	/// build the nodes on both side of that edge and count the connections.
	pub fn verify(&self, proof: CuckooMinerSolution, ease: u64) -> bool {
		let easiness = ease * (self.size as u64) / 100;
		let nonces = proof.to_u64s();
		let mut us = [0; PROOFSIZE];
		let mut vs = [0; PROOFSIZE];
		for n in 0..PROOFSIZE {
			if nonces[n] >= easiness || (n != 0 && nonces[n] <= nonces[n - 1]) {
				return false;
			}
			us[n] = self.new_node(nonces[n], 0);
			vs[n] = self.new_node(nonces[n], 1);
		}
		let mut i = 0;
		let mut count = PROOFSIZE;
		loop {
			let mut j = i;
			for k in 0..PROOFSIZE {
				// find unique other j with same vs[j]
				if k != i && vs[k] == vs[i] {
					if j != i {
						return false;
					}
					j = k;
				}
			}
			if j == i {
				return false;
			}
			i = j;
			for k in 0..PROOFSIZE {
				// find unique other i with same us[i]
				if k != j && us[k] == us[j] {
					if i != j {
						return false;
					}
					i = k;
				}
			}
			if i == j {
				return false;
			}
			count -= 2;
			if i == 0 {
				break;
			}
		}
		count == 0
	}
}



/// Utility to transform a 8 bytes of a byte array into a u64.
fn u8_to_u64(p: [u8; 32], i: usize) -> u64 {
	(p[i] as u64) | (p[i + 1] as u64) << 8 | (p[i + 2] as u64) << 16 |
		(p[i + 3] as u64) << 24 | (p[i + 4] as u64) << 32 | (p[i + 5] as u64) << 40 |
		(p[i + 6] as u64) << 48 | (p[i + 7] as u64) << 56
}

/// Implements siphash 2-4 specialized for a 4 u64 array key and a u64 nonce
pub fn siphash24(v: [u64; 4], nonce: u64) -> u64 {
	let mut v0 = v[0];
	let mut v1 = v[1];
	let mut v2 = v[2];
	let mut v3 = v[3] ^ nonce;

	// macro for left rotation
	macro_rules! rotl {
    ($num:ident, $shift:expr) => {
      $num = ($num << $shift) | ($num >> (64 - $shift));
    }
  }

	// macro for a single siphash round
	macro_rules! round {
    () => {
      v0 = v0.wrapping_add(v1);
      v2 = v2.wrapping_add(v3);
      rotl!(v1, 13);
      rotl!(v3, 16);
      v1 ^= v0;
      v3 ^= v2;
      rotl!(v0, 32);
      v2 = v2.wrapping_add(v1);
      v0 = v0.wrapping_add(v3);
      rotl!(v1, 17);
      rotl!(v3, 21);
      v1 ^= v2;
      v3 ^= v0;
      rotl!(v2, 32);
    }
  }

	// 2 rounds
	round!();
	round!();

	v0 ^= nonce;
	v2 ^= 0xff;

	// and then 4 rounds, hence siphash 2-4
	round!();
	round!();
	round!();
	round!();

	return v0 ^ v1 ^ v2 ^ v3;
}
